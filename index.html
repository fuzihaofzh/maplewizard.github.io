<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="BdchXXdzLi" />
  <meta name="google-site-verification" content="Js0CGXsHxNJBkQ55HoUIwJx6TuBtGbDARK2QTTE7DLA" />
  
  <title>切问录_blog</title>
  <meta name="author" content="Z.H. Fu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="切问录_blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/blog/images/favicon.png" rel="icon">
  <link rel="alternate" href="/blog/atom.xml" title="切问录_blog" type="application/atom+xml">
  <link rel="stylesheet" href="/blog/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F2489a13dce6ecb0fb337a44cf06a0e6e' type='text/javascript'%3E%3C/script%3E"));
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'true']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  
    <!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/blog/">切问录_blog</a></h1>
  <h2><a href="/blog/">$\mathscr{MATH\quad IS\quad FUN}$</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-19T13:41:22.000Z"><a href="/blog/2015/02/19/org-mode教程/">2015-02-19</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2015/02/19/org-mode教程/">org-mode入门教程</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="org-mode_入门教程"><center>org-mode 入门教程</center></h1><center>By Z.H. Fu</center><br><center>切问录 <a href="http://maplewizard.github.io">maplewizard.github.io</a>  </center>

<h1 id="org-mode_入门教程-1">org-mode 入门教程</h1><p> 　　org-mode是Emacs提供的一个强大的编辑模式，可以用于做会议笔记以及制作各种待办事项（GDT）。其语法类似于Markdown但是提供了比Markdown更多的操作，再加上Emacs强大的编辑功能，能给笔记增加很多动态的操作（能纯文本上实现折叠、展开、树状视图、表格求和、求代码运行结果等功能），可以说org-mode是最强大的标记语言。而org-mode的强大，也导致了他比markdown更加复杂，需要花些时间来练习，本文选出了org-mode最强大、实用的功能，进行最简单的介绍，下面介绍org-mode的使用方法。</p>
 <center><img src="/images/org-mode-unicorn-logo.png" alt="org-mode的logo"></center>


<h2 id="安装">安装</h2><p>　　<a href="http://www.gnu.org/software/emacs/">Emacs</a>最新版本（24.4）自带org-mode，这就意味着只要打开一个后缀名为org的文件就会自动进入org-mode。因此我们只需要下载最新版的Emacs即可。<br>　　<br>windows用户：到<a href="http://ftp.gnu.org/gnu/emacs/windows/">http://ftp.gnu.org/gnu/emacs/windows/</a> 下载最新版<br>ubuntu系列：在终端中输入：<code>sudo apt-get install emacs</code> </p>
<h2 id="配置">配置</h2><p>　　org-mode功能基本比较完善，不需要更多的配置，但是org模式下默认没有自动换行的功能，我们在.emacs文件里面添加如下代码，实现自动换行：</p>
<pre><code><span class="list">(<span class="keyword">add-hook</span> <span class="quoted">'org-mode-hook</span> <span class="list">(<span class="keyword">lambda</span> <span class="list">()</span> <span class="list">(<span class="keyword">setq</span> truncate-lines <span class="literal">nil</span>)</span>)</span>)</span>
</code></pre><p>　　</p>
<h2 id="实例教程">实例教程</h2><p>　　以下分别讲解org-mode下几个实用的功能，更完整的教程可以参考<a href="http://orgmode.org/orgguide.pdf">官网教程</a>。下面一步一步完成我们的org文件。（本教程中我们定义 <code>C-x</code> 表示按Ctrl+x，<code>M+x</code>标识Alt+x，<code>S+x</code>代表Shift+x，这也是Emacs的标准定义）</p>
<h3 id="新建文件">新建文件</h3><p>1) 打开Emacs<br>2) 输入 <code>C-x C-f ～/test/test.org</code> </p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/blog/2015/02/19/org-mode教程/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-01-17T05:59:25.000Z"><a href="/blog/2015/01/17/互信息的理解/">2015-01-17</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2015/01/17/互信息的理解/">互信息的理解</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="互信息（mutual_information）的理解"><center>互信息（mutual information）的理解</center></h1><center>By Z.H. Fu</center><br><center>切问录 <a href="http://maplewizard.github.io" target="_blank" rel="external">maplewizard.github.io</a>  </center>

<p>我们在之前研究过两个随机变量的独立性，我们定义若两个随机变量$X,Y$满足<br>$$P(X,Y)=P(X)P(Y)$$<br>则我们说随机变量$X,Y$独立。下面来直观地理解这个公式，可以发现，如果$X,Y$独立，那么已知$X$，将不会对$Y$的分布产生任何影响，即是说$P(Y)=P(Y|X)$，这个结果的证明也很简单，由贝叶斯公式：<br>$$P(Y|X)=\frac{P(X,Y)}{P(X)}=\frac{P(X)P(Y)}{P(X)}=P(Y)$$<br>即证。</p>
<p>由此可以看出，独立性反应了已知$X$的情况下，$Y$的分布是否会改变，或者说，在给定随机变量$X$之后，能否为$Y$带来额外的信息。然而独立性只能表示出两个随机变量之间是否会有关系，但是却不能刻画他们的关系大小。下面我们引入互信息，它不仅能说明两个随机变量之间是否有关系，也能反应他们之间关系的强弱。我们定义互信息$I(X,Y)$：<br>$$I(X;Y)=\int_X \int_Y P(X,Y)\log\frac{P(X,Y)}{P(X)P(Y)}$$</p>
<p>我们来稍微理解一下，log里面就是$X,Y$的联合分布和边际分布的比值，如果对所有$X,Y$，该值等于1，即是说他们独立的情况下，互信息$I(X;Y)=0$，即是说这两个随机变量引入其中一个，并不能对另一个带来任何信息，下面我们来稍稍对该式做一个变形<br>$$\begin{aligned}<br>I(X;Y)&amp;=\int_X \int_Y P(X,Y)\log\frac{P(X,Y)}{P(X)P(Y)}\\<br>&amp;=\int_X \int_Y P(X,Y)\log\frac{P(X,Y)}{P(X)}-\int_X \int_Y P(X,Y)\log{P(Y)}\\<br>&amp;=\int_X \int_Y P(X)P(Y|X)\log P(Y|X) -\int_Y \log{P(Y)}\int_X P(X,Y)\\<br>&amp;=\int_X P(X)\int_Y P(Y|X)\log P(Y|X)-\int_Y \log{P(Y)}P(Y)\\<br>&amp;=-\int_X P(X)H(Y|X=x)+H(Y)\\<br>&amp;=H(Y)-H(Y|X)\\<br>\end{aligned}$$</p>
<p>其中，$H(Y)$是$Y$的熵，定义为<br>$$H(Y)=-\int_Y P(Y)\log{P(Y)}$$<br>衡量的是$Y$的不确定度，即使说，$Y$分布得越离散，$H(Y)$的值越高，而$H(Y|X)$则表示在已知$X$的情况下，$Y$的不确定度，而$I(X;Y)$则表示由$X$引入而使$Y$的不确定度减小的量，因而如果$X,Y$关系越密切，$I(X;Y)$越大，$I(X;Y)$最大的取值是$H(Y)$，也就是说，$X,Y$完全相关，由于X的引入，$Y$的熵由原来的$H(Y)$减小了$I(X;Y)=H(Y)$，变成了0，也就是说如果$X$确定，那么$Y$就完全确定了。而当$X,Y$独立时，$I(X;Y)=0$引入$X$，并未给$Y$的确定带来任何好处。</p>
<p>总结下$I(X;Y)$的性质：<br>1）$I(X;Y)\geqslant 0$<br>2）$H(X)-H(X|Y)=I(X;Y)=I(Y;X)=H(Y)-H(Y|X)$<br>3）当$X,Y$独立时，$I(X;Y)=0$<br>4）当$X,Y$知道一个就能推断另一个时，$I(X;Y)=H(X)=H(Y)$</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-23T11:19:53.000Z"><a href="/blog/2014/10/23/仿射空间与仿射变换/">2014-10-23</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/10/23/仿射空间与仿射变换/">仿射空间与仿射变换</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="仿射空间与仿射变换"><center>仿射空间与仿射变换</center></h1><p><center>By Z.H. Fu</center></p>
<p><center>切问录 <a href="http://maplewizard.github.io" target="_blank" rel="external">maplewizard.github.io</a>  </center>
　　　　　　</p>
<h2 id="为什么需要仿射变换？">为什么需要仿射变换？　　</h2><p>　　仿射空间与仿射变换在计算机图形学中有着很重要的应用。在线性空间中，我们用矩阵乘向量的方法，可以表示各式各样的线性变换，完成诸多的功能，但是有一种极其常用的变换却不能用线性变换的方式表示，那就是平移，一个图形的平移是非线性的！（这一点只需要看平移前各点与原点的连线和平移后各点与原点之间的连线可知，或者记平移变换为$\mathcal{F}$，有$\mathcal{F}（\boldsymbol{v_1}+\boldsymbol{v_2}）\not =\mathcal{F}（\boldsymbol{v_1})+\mathcal{F}(\boldsymbol{v_2}））$
　　　　　　</p>
<h2 id="放射空间与仿射组合">放射空间与仿射组合</h2><p>　　为了用数学的方式来描述这种变换，就需要用到仿射变换（平移不是线性变换而是仿射变换）。下面先讲仿射空间。形象地来讲，仿射空间就是没有原点的线性空间。在线性空间中，两个点相加，可以定义为原点到两个点的向量线性相加，而在仿射空间中，由于没有原点，因此不能定义相加，没有线性组合。但我们可以定义一个仿射组合来用若干基表出某个点。我们定义仿射组合：<br>$$\boldsymbol{p}=\sum_{i=1}^N \lambda_i \boldsymbol{v_i}\quad\quad(\sum_{i=1}^N \lambda_i=1)$$<br>我们不妨在线性空间中来看这个式子，假设就两个向量$\boldsymbol{v_1,v_2}$我们任意指定一个原点$\boldsymbol{q}$，设$\boldsymbol{v_1}$的系数为$\lambda$，则$\boldsymbol{v_2}$的系数为$1-\lambda$，那么$\boldsymbol{p}=\boldsymbol{q}+\lambda(\boldsymbol{v_1}-\boldsymbol{q})+(1-\lambda)(\boldsymbol{v_2}-\boldsymbol{q})=\lambda \boldsymbol{v_1}+(1-\lambda)(\boldsymbol{v_2})$。通过推导，原点$\boldsymbol{q}$被消去了，也就是说，仿射组合跟原点的选择没有任何关系！
　　　　　　</p>
<h2 id="仿射变换">仿射变换</h2><p>　　有了仿射组合，就可以仿照线性组合来定义仿射变换：</p>
<blockquote>
<p>给定两个仿射空间$\mathcal{A},\mathcal{B}$，一个函数$f:\mathcal{A}\rightarrow \mathcal{B}$是仿射变换，当且仅当对仿射组合<br>$$\sum_{i=1}^N \lambda_i \boldsymbol{v_i}\quad\quad(\sum_{i=1}^N \lambda_i=1)$$都有<br>$$f(\sum_{i=1}^N \lambda_i \boldsymbol{v_i})=\sum_{i=1}^N \lambda_if(\boldsymbol{v_i})\quad\quad(\sum_{i=1}^N \lambda_i=1)$$</p>
</blockquote>
<p>这种系数又叫质心坐标，哪个点的系数大，就相当于质量大，质心就离那个点近。仿射变换得到的结果就是给定点按质量加权的质心，质心的仿射变换等于每个点进行放射变换后再求质心。
　　　　　　</p>
<h2 id="用线性变换表示仿射变换">用线性变换表示仿射变换</h2><p>下面来看如何表示仿射变换，我们定义$\mathbb{R}^n$中一个向量$\boldsymbol{v}$的齐次形式为$\mathbb{R}^{n+1}$中的$\overset{\sim}{\boldsymbol{v}}=\left[\begin{aligned}\boldsymbol{v} \\ 1\end{aligned}\right]$那么，仿射组合与系数和为1的要求可统一表示为<br>$$\left[\begin{aligned}\boldsymbol{y} \\ 1\end{aligned}\right]=c_1\left[\begin{aligned}\boldsymbol{v_1} \\ 1\end{aligned}\right]+c_2\left[\begin{aligned}\boldsymbol{v_2} \\ 1\end{aligned}\right]+\cdots+c_n\left[\begin{aligned}\boldsymbol{v_n} \\ 1\end{aligned}\right]$$<br>也就是说，仿射组合可以写成高一维对应齐次坐标的线性组合形式。那么对于一个附加平移的变换<br>$$\boldsymbol{y}=A\boldsymbol{x}+\boldsymbol{b}$$<br>我们可以将其改写成其次坐标的形式<br>$$\left[\begin{aligned}\boldsymbol{y} \\ 1\end{aligned}\right]=\left[\begin{aligned}&amp;A &amp;\boldsymbol{b} \\ &amp;0 &amp;1\end{aligned}\right]\cdot\left[\begin{aligned}\boldsymbol{x} \\ 1\end{aligned}\right]$$这也是在计算机图形学中对平移的处理方式。下面一个摘自维基百科的图形象地说明了这一过程</p>
<p><center><img src="/images/affinetransofrmation.gif" alt="affinetransofrmation.gif"></center>
 　　　　　　　　　　</p>
<h2 id="其它">其它</h2><p>　　我们再来看看质心坐标（Barycentric Coordinates），采用质心坐标的好处在于它能够表示每一点受周围点的影响，质心坐标的系数越大，影响越大，因此在线性插值时，可以直接用质心坐标来乘以每一点的值，得出的就是插值后的结果，在计算机图形学中进行渲染时，颜色差值就用这种算法。
 　　　　　　　　　　　　　　　　　　</p>
<h2 id="参考文献">参考文献</h2><p>[1]D C.Clay Linear Algebra and its application 4th edition<br>[2]<a href="http://en.wikipedia.org/wiki/Affine_space" target="_blank" rel="external">http://en.wikipedia.org/wiki/Affine_space</a><br>[3]<a href="http://en.wikipedia.org/wiki/Affine_transformation" target="_blank" rel="external">http://en.wikipedia.org/wiki/Affine_transformation</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-23T06:48:19.000Z"><a href="/blog/2014/10/23/用chrome修改js代码/">2014-10-23</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/10/23/用chrome修改js代码/">用chrome修改js代码</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="用chrome修改js代码"><center>用chrome修改js代码</center></h1><center>By Z.H. Fu</center><br><center>切问录 <a href="http://maplewizard.github.io">maplewizard.github.io</a>  </center>


<p>　　网页中大部分的限制都是由js编写的，而chrome提供了一个修改js代码的工具，利用这个工具可以轻松解决各种时间等待之类的限制。本文主要通过利用chrome命令行修改变量值得方式，控制运行流程。</p>
<center><img src="/images/chrome_button.PNG" alt="chrome_button.PNG"></center><br>如图，我们看到该网站有一个阅读等待时间，而且一直没有任何变化，我们的目的是跳过这个等待时间。步骤如下：<br>1、按F12，打开调试面板；<br>2、打开source面板，找到相对应的代码；<br><center><img src="/images/chrome_panel.PNG" alt="chrome_panel.PNG"></center><br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/blog/2014/10/23/用chrome修改js代码/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-08T14:24:43.000Z"><a href="/blog/2014/10/08/从Logistic回归到神经网络/">2014-10-08</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/10/08/从Logistic回归到神经网络/">从Logistic回归到神经网络</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="从Logistic回归到神经网络"><center>从Logistic回归到神经网络</center></h1><center>By Z.H. Fu</center><br><center>切问录 <a href="http://maplewizard.github.io">maplewizard.github.io</a>  </center>

<h2 id="sigmoid函数">sigmoid函数</h2><p>sigmoid函数定义为<br>$$g(z)=\frac{1}{1+e^{-z}}$$<br>对于一般的模型，通常有$z=\theta^{\mathrm{T}}x$，可以看做是样本各属性的加权。sigmoid函数求导有$g’(z)=g(z)(1-g(z))$，这个在神经网络推导的时候会用到。</p>
<h2 id="Logistic回归">Logistic回归</h2><p>Logistic回归是针对二分类问题常用的一种回归，其回归模型为：<br>$$h_\theta(x)=\frac{1}{1+e^{-\theta^{\mathrm{T}}x}}$$<br>其中$x$是某个样本的属性向量，$\theta$是参数向量。在用Logistic回归时，需要找到合适的参数$\theta$，使得能量函数（误差）$J(\theta)$最小，在使用梯度下降法更新参数$\theta$的更新过程中需要使用到梯度，然后在每一步执行$\theta:=\theta-\alpha\nabla_\theta J(\theta)$，其中$\alpha是学习速度$，能量函数被定义为：<br>$$J(\theta)=-\frac{1}{m}\sum_{i=1}^m\left[y^{(i)}\log h_{\theta}(x^{(i)})+(1-y^{(i)})\log (1-h_{\theta}(x^{(i)}))\right]$$<br>其中<br>$$h_{\theta}(x^{(i)})=\frac{1}{1+e^{-\theta^{\mathrm{T}}x^{(i)}}}$$<br>下面来给出其梯度的推导<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/blog/2014/10/08/从Logistic回归到神经网络/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-08-30T15:30:56.000Z"><a href="/blog/2014/08/30/从力做功到质能方程/">2014-08-30</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/08/30/从力做功到质能方程/">从力做功到质能方程</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="从力做功到质能方程"><center> 从力做功到质能方程   </center></h1><center>By Z.H. Fu</center><br><center>切问录 <a href="http://maplewizard.github.io" target="_blank" rel="external">maplewizard.github.io</a>  </center>


<blockquote>
<p>$\mathcal{Everything~should~be~made~as~simple~as~possible,~but~not~ simpler.}$</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　$–\mathcal{Albert\quad Einstein}$</p>
</blockquote>
<p>$$\begin{align}<br>E&amp;=\int_0^xFdx<br>=\int_0^x\frac{d}{dt}(mv)dx<br>=\int_0^t\frac{d}{dt}(mv)vdt<br>=\int_0^{mv}vd(mv)<br>=\int_0^v vd\left(\frac{m_0v}{\sqrt{1-(v/c)^2}}\right)\\<br>&amp;=m_0\int_0^v\left(\frac{v}{[1-(v/c)^2]^{1/2}}+\frac{v^3/c^2}{[1-(v/c)^2]^{3/2}}\right)dv<br>=m_0\int_0^v\frac{vdv}{[1-(v/c)^2]^{3/2}}\\<br>&amp;=m_0c^2\left(\frac{1}{[1-(v/c)^2]^{1/2}}-1\right)<br>=(mc^2-m_0c^2)<br>=(m-m_0)c^2\Rightarrow<br>\end{align}$$<br>$$E=mc^2$$</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-08-27T13:01:18.000Z"><a href="/blog/2014/08/27/C++语言精要/">2014-08-27</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/08/27/C++语言精要/">C++语言精要</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="C++语言精要"><center>C++语言精要</center></h1><p><center>By Z.H. Fu</center></p>
<p><center>切问录 <a href="http://maplewizard.github.io">maplewizard.github.io</a>  </center></p>
<h3 id="几种必考虑的情况">几种必考虑的情况</h3><ul>
<li>只要有除法，就一定要讨论分母为0；</li>
<li>一定要判断函数输入参数是否合法；</li>
<li>指针使用时判断是否非0，用完了置为0。</li>
</ul>
<h3 id="函数压栈顺序">函数压栈顺序</h3><p>从右往左。<br>所以</p>
<pre><code><span class="keyword">int</span> g = <span class="number">1</span>;
<span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>, <span class="variable">%d</span>"</span>, g, ++g);
</code></pre><p>结果为2,2</p>
<pre><code><span class="keyword">int</span> g = <span class="number">1</span>;
<span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>, <span class="variable">%d</span>"</span>, g, g++);
</code></pre><p>结果为2,1，说明g++.exe是解析一个参数就加一次，不是解析完一行再加。</p>
<h3 id="条件解析顺序">条件解析顺序</h3><p>从左往右，如果当前已经足以判断（&amp;&amp;前面是False或||前面是True），则不会计算后续条件。</p>
<h3 id="boolalpha">boolalpha</h3><p>函数名称，功能是把bool值显示为true或false。</p>
<pre><code><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl; 
</code></pre><h3 id="(int_&amp;)">(int &amp;)</h3><p>float a = 1.0f<br>cout&lt;&lt;(int &amp;)a<br>从a的起始地址开始，读取sizeof(int)长度，当整数输出</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/blog/2014/08/27/C++语言精要/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-07-21T11:50:45.000Z"><a href="/blog/2014/07/21/拉普拉斯变换中的s是什么/">2014-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/07/21/拉普拉斯变换中的s是什么/">拉普拉斯变换中的s是什么</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="拉普拉斯变换中的s是什么"><center>拉普拉斯变换中的s是什么</center></h1><p><center>By Z.H. Fu</center></p>
<p><center>切问录 <a href="http://maplewizard.github.io" target="_blank" rel="external">maplewizard.github.io</a>  </center><br>　　今天重新研究了下拉普拉斯变换，很多资料只是给出了其公式，并没有给出其来历，特别是那个$s$的出现显得非常莫名其妙。本文旨在给出拉普拉斯变换的一个直观上的理解，对严谨性不做保证。<br>　　我们在研究很多数学问题的时候，特别是一些复杂的问题的时候，无法直接入手，而是将问题分解到许多维度上去，在这些简单的维度去进行处理，因此我们有了泰勒展开，有了幂级数、傅里叶级数，我们将傅里叶技级数再往连续域上推广，又有了傅里叶变换。而拉普拉斯变换，可以从幂级数的概念中推广出来，下面给出其推广过程。<br>一个函数可以用幂级数的形式表出：<br>$$A(x)=\sum_{i=1}^\infty a_ix^i$$<br>我们可以看出，构造一个函数$A(x)$的过程，我们输入了一个序列${a_1,a_2,\cdots}$，输出了一个函数$A(x)$，（这个地方的$x$是输出的函数的自变量，和拉普拉斯变换的定义还稍有不同，我们一会来解决这个问题），其实这个序列可以看成是一个特殊的函数，即自变量只取整数的函数，那么我们将其推广为一般函数会有什么效果？将离散自变量$i$用连续自变量$t$代替，求和推广为积分，我们有：<br>$$A(x)=\int_0^{+\infty} f(t)x^tdt$$<br>而在微积分中，我们常常引入自然指数来方便运算，有：<br>$$\begin{aligned}A(x)&amp;=\int_0^{+\infty} f(t)x^tdt\\<br>&amp;=\int_0^{+\infty} f(t)(e^{\ln x})^tdt<br>\end{aligned}$$<br>在这里，我们需要对$x$做一些限定，因为幂级数存在收敛半径的，对于一般的自然界中存在的实际函数（如信号）是不能发散到正无穷的，因此该函数有上界，因而，对于$x\lt 1$的幂级数一定收敛（可以用$\sqrt[n]{a_n}$那个半径判据），即幂级数收敛半径为1，而由于为了避免负的幂带来的困扰，我们要求$x\gt 0$。由于$0\lt x \lt 1$，而$\ln x \in (-\infty,0)$。也就是说，这样我们得到的变换的函数对其自变量的范围有所限制，为$x \in (0,1)$，这当然很不好看，因此我们做一个代换，令<br>$$-s=\ln x$$<br>将$A(x)$用$F(x)$代替，因此原始变为<br>$$F(x)=\int_0^{+\infty}f(t)e^{-st}dt\quad s \in(0,+\infty)$$<br>这正是拉普拉斯变换！<br>　　注意了，这里，我们变换后的函数本来是$F(x),x\in(0,1)$，但是，这种形式很难看，在操作时也很麻烦，因此我们做了变量代换，得到了变换后的函数$F(s),s\in(0,+\infty)$两个其实是一回事。将拉普拉斯变换用符号$\mathcal{L}$表示，记作：<br>$$\mathcal{L}(f(t))=F(s)$$</p>
<p>参考文献：<br>[1] 微分方程公开课.Massachusetts Institute of Technology.Arthur Mattuck</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-06-13T12:34:58.000Z"><a href="/blog/2014/06/13/为什么最小二乘法对误差的估计要用平方/">2014-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/06/13/为什么最小二乘法对误差的估计要用平方/">为什么最小二乘法对误差的估计要用平方？</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="为什么最小二乘法对误差的估计要用平方？"><center>为什么最小二乘法对误差的估计要用平方？</center></h1><p><center>By Z.H. Fu</center></p>
<p><center>切问录 <a href="http://maplewizard.github.io" target="_blank" rel="external">maplewizard.github.io</a>  </center><br>　　以前上高中的时候问过数学老师这个问题，被老师骂了一顿，说这是规定，后来也就没太在意。今天看了Stanford Andrew Ng讲的《机器学习》，明白了为什么最小二乘法对误差的估计要用平方，而不是绝对值或是四次方。</p>
<p>　　简单地说，之所以要用这种规定，是因为，取二次方的时候，对参数的估计是当前样本下的最大似然估计。下面给出证明。</p>
<p>　　记样本为$(x^{(i)},y^{(i)})$，对样本的预测为$\hat y^{(i)}|_\boldsymbol{\theta}$该记法表示该预测依赖于参数$\boldsymbol{\theta}$的选取。我们有：<br>　　$$\boldsymbol{y}=\boldsymbol{\hat y|_\theta}+\boldsymbol{\epsilon}$$<br>　　其中，$\boldsymbol{\epsilon}$是一个误差函数，我们通常认为其服从正态分布即<br>　　$$\boldsymbol{\epsilon }\sim N(0,\sigma^2)$$<br>因此有<br>　　$$\begin{aligned}\boldsymbol{y}-\boldsymbol{\hat y|_\theta}&amp;\sim N(0,\sigma^2)\\ \boldsymbol{y}&amp;\sim N(\boldsymbol{\hat y|_\boldsymbol{\theta}},\sigma^2)\end{aligned}$$<br>要求$\boldsymbol{\theta}$的极大似然估计，即是说，我们现在得到的这个真实存在的$\boldsymbol{y}$在$\boldsymbol{\theta}$不同的取值下，出现概率最大，我们来看这个概率。令<br>$$L(\boldsymbol{\theta})=P(\boldsymbol{y}|\boldsymbol{x};\boldsymbol{\theta})=\prod_{i=1}^m\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y^{(i)}-\hat y^{(i)}|_\boldsymbol{\theta})^2}{2\sigma})$$<br>为了简化计算，令<br>$$\begin{aligned}l(\boldsymbol{\theta})&amp;=\log L(\boldsymbol{\theta})\\&amp;=m\log \frac{1}{\sqrt{2\pi}}+\sum_{i=0}^m-\frac{(y^{(i)}-\hat y^{(i)}|_\boldsymbol{\theta})^2}{2\sigma}\end{aligned}$$<br>要让$L(\boldsymbol{\theta})$最大，即需让$l(\boldsymbol{\theta})$最大，即让$\sum_{i=0}^m(y^{(i)}-\hat y^{(i)}|_\boldsymbol{\theta})^2$取到最小值。</p>
<p>　　综上，当误差函数定为平方时，参数$\boldsymbol{\theta}$是样本的极大似然估计。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-07T05:18:35.000Z"><a href="/blog/2014/05/07/基于奇异值分解的图像压缩/">2014-05-07</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/05/07/基于奇异值分解的图像压缩/">基于奇异值分解的图像压缩</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="基于奇异值分解的图像压缩"><center>基于奇异值分解的图像压缩</center></h1><p><center>By Z.H. Fu</center></p>
<p><center>切问录 <a href="http://maplewizard.github.io">maplewizard.github.io</a>  </center><br>最近学习线性代数的有关东西，在看到奇异值分解（svd）时，发现了一个在图像压缩上的应用。<br>奇异值分解：在线性代数中，我们知道对任意一个矩阵都存在奇异值分解，$\boldsymbol{A}=\boldsymbol{U\Sigma V^\mathrm{T}}$，其中$\boldsymbol{U}$和$\boldsymbol{V}$是标准正交矩阵，而$\boldsymbol{\Sigma}$是一个对角矩阵，每一个对角元是该矩阵的一个奇异值，奇异值指的是矩阵的特征值开根号。其具体分解形式如下：<br>$$<br>\boldsymbol{A}=\begin{bmatrix}u_1 &amp;u_2 &amp;\cdots &amp;u_m\end{bmatrix}\begin{bmatrix}\boldsymbol{D} &amp; \boldsymbol{0} \\\boldsymbol{0} &amp;\boldsymbol{0}\end{bmatrix}\begin{bmatrix}v_1^\mathrm{T}\\ v_2^\mathrm{T} \\ \vdots \\ u_n^\mathrm{T}\end{bmatrix}<br>$$<br>其中<br>$$\boldsymbol{D}=\begin{bmatrix} \sigma_1 &amp;0 &amp;\cdots &amp;0 \\ 0 &amp; \sigma_2 &amp;\vdots &amp;0 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ 0 &amp;0 &amp;\cdots &amp;\sigma_r\end{bmatrix}$$<br>将$\boldsymbol{A}$展开得<br>$$\boldsymbol{A}=\sigma_1\boldsymbol{u_1v_1^\mathrm{T}}+\sigma_2\boldsymbol{u_2v_2^\mathrm{T}}+\cdots+\sigma_r\boldsymbol{u_rv_r^\mathrm{T}}$$<br>将$\boldsymbol{A}$看成一个图像的矩阵，上面和式的每一个分量按大小排序，越大，说明越重要。而后面的权很小，可以舍去，如果只取前面k项，则数据量为$(m+n+1)k\ll mn$因而达到了压缩图像的目的。<br>通过对比发现，当$k=\frac{r}{20} $时，能基本看清图像。当$k=\frac{r}{4} $时基本看不出任何区别，对于长宽相等的图像，此时数据量占原数据量的$k=\frac{2k}{n} $,在测试图像中，这个数值为0.5 。可见图像压缩的效果是显著的。<br>处理结果如下：<br>原始图像：</p>
<p><center><img src="/images/svdori.png" alt="svdori.png"></center><br>k=1:</p>
<p><center><img src="/images/svdk=1.png" alt="svdk=1.png"></center><br>k=2:<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/blog/2014/05/07/基于奇异值分解的图像压缩/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/2/">下一页 &raquo;</a>
    </nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:www.fuzihao.org/blog">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/blog/2015/02/19/org-mode教程/">org-mode入门教程</a>
      </li>
    
      <li>
        <a href="/blog/2015/01/17/互信息的理解/">互信息的理解</a>
      </li>
    
      <li>
        <a href="/blog/2014/10/23/仿射空间与仿射变换/">仿射空间与仿射变换</a>
      </li>
    
      <li>
        <a href="/blog/2014/10/23/用chrome修改js代码/">用chrome修改js代码</a>
      </li>
    
      <li>
        <a href="/blog/2014/10/08/从Logistic回归到神经网络/">从Logistic回归到神经网络</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/blog/categories/C/">C++</a><small>1</small></li>
  
    <li><a href="/blog/categories/Fortran/">Fortran</a><small>1</small></li>
  
    <li><a href="/blog/categories/Hexo/">Hexo</a><small>1</small></li>
  
    <li><a href="/blog/categories/Intuitive-Math/">Intuitive Math</a><small>2</small></li>
  
    <li><a href="/blog/categories/LaTeX/">LaTeX</a><small>1</small></li>
  
    <li><a href="/blog/categories/Linux/">Linux</a><small>1</small></li>
  
    <li><a href="/blog/categories/Python/">Python</a><small>3</small></li>
  
    <li><a href="/blog/categories/历史/">历史</a><small>2</small></li>
  
    <li><a href="/blog/categories/图像处理/">图像处理</a><small>2</small></li>
  
    <li><a href="/blog/categories/工具应用/">工具应用</a><small>1</small></li>
  
    <li><a href="/blog/categories/数学杂谈/">数学杂谈</a><small>13</small></li>
  
    <li><a href="/blog/categories/有限元/">有限元</a><small>1</small></li>
  
    <li><a href="/blog/categories/机器学习/">机器学习</a><small>1</small></li>
  
    <li><a href="/blog/categories/物理随笔/">物理随笔</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/blog/tags/Bernstein多项式/" style="font-size: 10px;">Bernstein多项式</a><a href="/blog/tags/Bezier曲线/" style="font-size: 10px;">Bézier曲线</a><a href="/blog/tags/C/" style="font-size: 10px;">C++</a><a href="/blog/tags/Emacs/" style="font-size: 10px;">Emacs</a><a href="/blog/tags/Fortran/" style="font-size: 10px;">Fortran</a><a href="/blog/tags/LaTeX/" style="font-size: 15px;">LaTeX</a><a href="/blog/tags/Logistic/" style="font-size: 10px;">Logistic</a><a href="/blog/tags/Python/" style="font-size: 20px;">Python</a><a href="/blog/tags/beamer/" style="font-size: 10px;">beamer</a><a href="/blog/tags/chrome/" style="font-size: 10px;">chrome</a><a href="/blog/tags/markdown/" style="font-size: 10px;">markdown</a><a href="/blog/tags/marked/" style="font-size: 10px;">marked</a><a href="/blog/tags/mathJax/" style="font-size: 10px;">mathJax</a><a href="/blog/tags/matplotlib/" style="font-size: 20px;">matplotlib</a><a href="/blog/tags/互信息/" style="font-size: 10px;">互信息</a><a href="/blog/tags/仿射变换/" style="font-size: 10px;">仿射变换</a><a href="/blog/tags/优化/" style="font-size: 10px;">优化</a><a href="/blog/tags/历史/" style="font-size: 15px;">历史</a><a href="/blog/tags/变分法/" style="font-size: 15px;">变分法</a><a href="/blog/tags/国史大纲/" style="font-size: 10px;">国史大纲</a><a href="/blog/tags/奇异值分解/" style="font-size: 10px;">奇异值分解</a><a href="/blog/tags/并行计算/" style="font-size: 10px;">并行计算</a><a href="/blog/tags/张量，度量张量/" style="font-size: 10px;">张量，度量张量</a><a href="/blog/tags/形态学/" style="font-size: 10px;">形态学</a><a href="/blog/tags/微积分/" style="font-size: 10px;">微积分</a><a href="/blog/tags/惯性矩/" style="font-size: 10px;">惯性矩</a><a href="/blog/tags/拉普拉斯变换/" style="font-size: 10px;">拉普拉斯变换</a><a href="/blog/tags/散度定理/" style="font-size: 10px;">散度定理</a><a href="/blog/tags/数据压缩/" style="font-size: 10px;">数据压缩</a><a href="/blog/tags/斐波那契数列/" style="font-size: 10px;">斐波那契数列</a><a href="/blog/tags/最小二乘/" style="font-size: 10px;">最小二乘</a><a href="/blog/tags/有限元/" style="font-size: 10px;">有限元</a><a href="/blog/tags/机器学习/" style="font-size: 10px;">机器学习</a><a href="/blog/tags/样条曲线/" style="font-size: 10px;">样条曲线</a><a href="/blog/tags/格林公式/" style="font-size: 10px;">格林公式</a><a href="/blog/tags/格林恒等式/" style="font-size: 10px;">格林恒等式</a><a href="/blog/tags/概率/" style="font-size: 10px;">概率</a><a href="/blog/tags/正定矩阵/" style="font-size: 10px;">正定矩阵</a><a href="/blog/tags/海森矩阵，最小作用量/" style="font-size: 10px;">海森矩阵，最小作用量</a><a href="/blog/tags/点云重建/" style="font-size: 10px;">点云重建</a><a href="/blog/tags/积分/" style="font-size: 15px;">积分</a><a href="/blog/tags/线性代数/" style="font-size: 15px;">线性代数</a><a href="/blog/tags/组合数学/" style="font-size: 10px;">组合数学</a><a href="/blog/tags/读书笔记/" style="font-size: 10px;">读书笔记</a><a href="/blog/tags/雅克比矩阵/" style="font-size: 10px;">雅克比矩阵</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://zipperary.com/" title="Zippera's Blog">Zippera</a></li>
<li><a href="http://www.lixthu.com/" title="La Fantasia">La Fantasia</a></li>
<li><a href="http://zh.lucida.me/" title="lucida">lucida</a></li>
<li><a href="http://zhiqiang.org/blog/" title="阅微堂">阅微堂</a></li>
<li><a href="http://lukang.me/" title="Kang Lu' Blog">Kang Lu' Blog</a></li>
</ul>
</div>


  <div class="widget recent comments">
<h3 class="title">最新评论</h3>
<ul class="ds-recent-comments" data-num-items="10" data-show-avatars="1" data-show-time="1" data-show-admin="1" data-excerpt-length="70"></ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"maplewizard"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Z.H. Fu
  
</div>
<div class="clearfix"></div></footer>
  <script src="/blog/js/jquery.min.js"></script>
<script src="/blog/js/jquery.imagesloaded.min.js"></script>
<script src="/blog/js/gallery.js"></script>




<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>